--Scenario based queries
--------------------------------------------------------------Set 1-----------------------------------------------------------------------------------------------
--1.Write a SQL query to find the customers  who bought every product in the last 6 months. Retrieve customer details.
---------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from 
    sales.customers C
    join sales.orders O
    on C.customer_id=O.customer_id
    join sales.order_items OI
    on O.order_id=OI.order_id
    join production.products P
    on OI.product_id=P.product_id
where 
    O.order_date>=dateadd(month,-6,(select max(order_date) from sales.orders))
group by 
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct OI.product_id)=(select count(distinct product_id) from production.products);


    --This query works without error,but produces no output since,
    --in the last 6 months,there is no single customer who purchased all of the products

--2.Identify the most sold product (by quantity) for each store and display the product name, store name, and total quantity sold.	
----------------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        ST.store_name,P.product_name,sum(quantity) as QuantitySold,
        rank() over (partition by ST.store_name order by sum(quantity) desc) as Rnk
    from 
        sales.stores ST join sales.orders O on 
        ST.store_id=O.store_id join sales.order_items OI
        on O.order_id=OI.order_id join production.products P
        on OI.product_id=P.product_id
    group by 
        ST.store_name,P.product_name
)
select 
    X.store_name,X.product_name,X.QuantitySold 
from 
    X
where 
    X.Rnk=1;


--3.Write a query to rank customers based on the most expensive product they purchased in each product category.
---------------------------------------------------------------------------------------------------------------------------
-- Firstly, we group the customers and aggreagte to find who ever bought the expensive product in each category and then
-- partition the category to rank each customer by price 
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name,CG.category_id,CG.category_name,
    P.product_name,max(P.list_price) as MaxPrice,
    dense_rank() over (partition by CG.category_id order by max(P.list_price) desc) as RNK
from 
    sales.customers C join sales.orders O on C.customer_id=O.customer_id
    join sales.order_items OI on O.order_id=OI.order_id join
    production.products P on OI.product_id=P.product_id
    join production.categories CG on P.category_id=CG.category_id
group by 
    C.customer_id,C.first_name,C.last_name,CG.category_name,P.product_name,CG.category_id

--4.Calculate the Year-over-Year Sales Growth.
-------------------------------------------------------------
use BikeStorePracticeDB;
select 
    X.*,
    --calculate growth percentage
    (TotalSales-nullif(PreviousYearSales,0))/PreviousYearSales*100 as GrowthPercent
from
    (
    --calculate year by year total sales and previous sales
    select 
        year(O.order_date) as Year,
        sum(OI.quantity*OI.list_price) as TotalSales,
        lag(sum(OI.quantity*OI.list_price),1,0) over (order by year(O.order_date)) as PreviousYearSales 
    from 
        sales.orders O join sales.order_items OI on O.order_id=OI.order_id
    group by 
        year(O.order_date)
        ) 
    X;


--5.Find the cumulative revenue generated per store over time
-----------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_id,ST.store_name,O.order_date,
    sum(OI.quantity*OI.list_price) over (partition by ST.store_id order by O.order_date,O.customer_id) as RunningTotalSales
from 
    sales.Orders O join sales.stores ST on
    O.store_id=ST.store_id join sales.order_items OI
    on O.order_id=OI.order_id;

--6.
-------------------------------------------------------------------------
--duplicate
--same as 5th one

--7.Calculate the total revenue generated by each store, rank the stores based on the total number of orders. Retrieve store_id, total orders (ORDER BY store_id ASC).
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_id,
    count(O.order_id) as Total_orders,
    sum(quantity*(list_price*(1-discount))) as TotalRevenue,
    rank() over (order by count(O.order_id) desc) as rNK
from 
    sales.stores ST join sales.orders O
    on ST.store_id=O.store_id
    join sales.order_items OI
    on O.order_id=OI.order_id
group by 
    ST.store_id
order by 
    ST.store_id;


--8.Find the customers who have spent the most in each store	
-------------------------------------------------------------------------------------------
--firstly we extract every customers total spending in each store.
use BikeStorePracticeDB;
with X as (
    select 
        C.customer_id,C.first_name,C.last_name,ST.store_id,ST.store_name,
        sum(quantity*(list_price*(1-discount))) as Total_spending -- total spending excluding the discount percentage from list price
    from 
        sales.customers C join sales.orders O 
        on C.customer_id=O.customer_id
        join sales.order_items OI
        on O.order_id=OI.order_id
        join sales.stores ST on
        O.store_id=ST.store_id
    group by 
        C.customer_id,ST.store_id,C.first_name,C.last_name,ST.store_name
       ),
-- then we rank each customer in each store by total sales
Y as (
    select 
        X.*,
        row_number() over (partition by store_name order by X.Total_spending desc) as RN
    from 
        X
)
-- then we finally select the top spending customer across each store
select 
    store_id,store_name,customer_id,first_name,last_name,Total_spending
from 
    Y
where 
    Y.RN=1
order by 
    store_id;


--9.Find the customer name who rented the maximum number of films in the last 5 years, where each film features at least two actors.
-------------------------------------------
use sakila;
select top 1 
    C.first_name,C.last_name,
    count(R.rental_id) as No_of_rentals
from 
    customer C join rental R on C.customer_id=R.customer_id
    join inventory I on R.inventory_id=I.inventory_id join
    film F on I.film_id=F.film_id join
    film_actor FA on F.film_id=FA.film_id
where 
    F.film_id in(
            select 
                film_id 
            from 
                film_actor
            group by 
                film_id
            having 
                count(distinct actor_id)>=2
            )
group by 
    C.first_name,C.last_name
order by 
    No_of_rentals desc;


--10.Rank the stores by their total revenue
----------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_name,
    sum(OI.quantity*OI.list_price) as TotalSales,
    rank() over (order by sum(OI.quantity*OI.list_price) desc) as SalesRank
from 
    sales.orders O join sales.stores ST on 
    O.store_id=ST.store_id join sales.order_items OI
    on O.order_id=OI.order_id
group by 
    ST.store_name;


--11.Rank products within each category based on their total sales
-----------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    CG.category_name,P.product_name,
    sum(OI.quantity*OI.list_price) as TotalSales,
    rank() over (partition by CG.category_name order by sum(OI.quantity*OI.list_price) desc) as Rnk
from 
    sales.order_items OI join production.products P
    on OI.product_id=P.product_id join
    production.categories CG on P.category_id=CG.category_id
group by 
    CG.category_name,P.product_name

 ;

--12.Find all customers who have placed an order every month in the last 6 months.
----------------------------------------------------------------------------------------------
/*firstly select customer details,
then apply date filter as before 6 months,
here we apply the filter to extract only the records which are 6 months before from last order date
and then group by customer details to find out the count agregate
and to find out whether order has been placed in each of the month,
we create a special identifier for each month like year(order_date)*100+month(order_date)
like for march 2025 it would be  202503 ((2025*100) +3) so that it will be different from other months id
and when counted for distinct months, it must be 6 according to the requirement*/

use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from 
    sales.customers C join sales.orders O on
    C.customer_id=O.customer_id
where 
    O.order_date>=dateadd(month,-6,(select max(order_date) from sales.orders))
    and O.order_date<(select max(order_date) from sales.orders)
group by 
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct (year(order_date)*100+month(order_date)))=6;


--13.Write a SQL query to find top 3 category purchases in each city
------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        C.city,CG.category_name,
        sum(OI.quantity*OI.list_price) as TotalSales,
        rank() over (partition by C.city order by sum(OI.quantity*OI.list_price) desc) as CategoryRank
    from 
        sales.customers C join sales.orders O
        on C.customer_id=O.customer_id join sales.order_items OI
        on O.order_id=OI.order_id join production.products P
        on OI.product_id=P.product_id join production.categories CG
        on P.category_id=CG.category_id
    group by 
        C.city,CG.category_name
)
select 
    * 
from 
    X 
where
    X.CategoryRank<=3;


--14.Find the top 3 products that contributed the most to revenue for a specific store. (ORDER BY model_year DESC).
-----------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        ST.store_id,ST.store_name,OI.product_id,P.product_name,P.model_year,
        sum(OI.quantity*OI.list_price) as Total_revenue,
        row_number() over (partition by ST.store_id order by  sum(OI.quantity*OI.list_price) desc) as ProductRank
    from 
        sales.stores ST join sales.orders O
        on ST.store_id=O.store_id join sales.order_items OI on
        O.order_id=OI.order_id join production.products P on
        OI.product_id=P.product_id
    group by 
        ST.store_id,ST.store_name,OI.product_id,P.product_name,P.model_year
)
select 
    * 
from 
    X 
where 
    X.ProductRank<=3 
order by 
    model_year desc;


------------------------------------------------------------------SET 2---------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
--1.Find the top 3 highest revenue-generating stores over time using cumulative revenue.
----------------------------------------------------------------------------------------------------------------------------
--select 
--    ST.store_id,ST.store_name,
--    sum(OI.quantity*OI.list_price) over (partition by O.order_date) as CumulativeRevenue
--from
--    sales.stores ST join sales.orders O on
--    ST.store_id=O.store_id join sales.order_items OI on
--    O.order_id=OI.order_id
--group by
--     ST.store_id,ST.store_name


--2.Identify the top 3 best-selling products in each store (Concepts: RANK() or DENSE_RANK()).
----------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    X.* 
from (
    select 
        ST.store_id,ST.store_name,P.product_id,P.product_name,
        sum(OI.quantity) as Total_selling_quantity,
        rank() over (partition by ST.store_id order by sum(OI.quantity) desc) as Rnk
    from 
        sales.stores ST join sales.orders O on
        ST.store_id=O.store_id join sales.order_items OI on 
        O.order_id=OI.order_id join production.products P on
        OI.product_id=P.product_id
    group by 
        ST.store_id,ST.store_name,P.product_id,P.product_name
    ) 
    X
where 
    X.Rnk<=3;

--3.Find the top 3 products, along with their category and brand names, where the delay between the placement of the order and dispatch is the maximum.
------------------------------------------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select top 3 
    P.product_id,P.product_name,CG.category_name,B.brand_name,
    max(datediff(day,O.required_date,O.shipped_date)) as Max_Delayed_days
from 
    sales.orders O join sales.order_items OI on 
    O.order_id=OI.order_id join production.products P on
    OI.product_id=P.product_id join production.categories CG on
    P.category_id=CG.category_id join production.brands B on
    P.brand_id=B.brand_id
group by 
    P.product_id,P.product_name,CG.category_name,B.brand_name
order by 
    max(datediff(day,O.required_date,O.shipped_date)) desc;


--4.NTILE-Dividing products into price Tiers: Group items into price ranges.
---------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    product_id,product_name,list_price,
    ntile(4) over (order by list_price desc) as price_tier
from 
    production.products;

--5.RANK & DENSE_RANK - Finding Top Selling Products in a Specific Store: Rank 
--items by sales within any group.------------------
use BikeStorePracticeDB;
select 
    ST.store_id,ST.store_name,P.product_id,P.product_name,
    sum(OI.quantity*OI.list_price) as Total_sales,
    rank() over (partition by ST.store_id order by sum(OI.quantity*OI.list_price) desc) as Rnk,
    dense_rank() over (partition by ST.store_id order by sum(OI.quantity*OI.list_price) desc) as DnsRnk
from 
    sales.stores ST join sales.orders O on
    ST.store_id=O.store_id join sales.order_items OI on
    O.order_id=OI.order_id join production.products P on
    OI.product_id=P.product_id
group by 
    ST.store_id,ST.store_name,P.product_id,P.product_name;

--6.PARTITION BY with LEAD & LAG - Comparing Daily Sales: Compare values to previous/next rows within a group.	
----------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        ST.store_id,ST.store_name,O.order_date,
        sum(OI.quantity*OI.list_price) as DailySales
    from 
        sales.stores ST join sales.orders O on
        ST.store_id=O.store_id join sales.order_items OI on
        O.order_id=OI.order_id
    group by 
        ST.store_id,O.order_date,ST.store_name
)
select 
    X.store_id,X.store_name,X.order_date,X.DailySales,
    lag(X.DailySales) over (partition by X.store_id order by X.order_date) as PreviousDaySales,
    lead(X.DailySales) over (partition by X.store_id order by X.order_date) as NextDaySales,
    (X.DailySales-lag(X.DailySales) over (partition by X.store_id order by X.order_date)) as SalesDifference
from 
    X;

--7.Understand datefunctions , group by , count and use window functions / cte to handle year-over-year analysis
--------------------------------------------------------------------------------------------
use sakila;
select 
    A.actor_id,A.first_name,A.last_name,F.release_year,
    count(F.film_id) as FilmCount
    --avg(count(F.film_id)) as AvgYearlyReleases
from 
    actor A join film_actor FA on A.actor_id=FA.actor_id
    join film F on FA.film_id=F.film_id
group by 
    A.actor_id,A.first_name,A.last_name,F.release_year;


--8.Find stores that have sales on all days of the week
--------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_id,ST.store_name,count(order_id) as Total_orders
from 
    sales.stores ST join sales.orders O on
    ST.store_id=O.store_id
group by 
    ST.store_id,ST.store_name
having 
    count(distinct datepart(weekday,order_date))=7;

--9.List stores that have sold products from every category
-----------------------------------------------------------------------------------------
select 
    ST.store_id,ST.store_name
from
    sales.stores ST join production.stocks SK
    on ST.store_id=SK.store_id join 
    production.products P on SK.product_id=P.product_id
    join production.categories CG on
    P.category_id=CG.category_id
group by
    ST.store_id,ST.store_name
having
    count(distinct CG.category_id)=(
    select count(distinct category_id) from production.categories
    );

--10.Identify customers who placed orders in exactly 3 different months last year.
-------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from
    sales.customers C join sales.orders O on 
    C.customer_id=O.customer_id
where
    order_date>dateadd(year,-1,(select max(order_date) from sales.orders))
    and order_date<=(select max(order_date) from sales.orders)
group by
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct year(O.order_date)*100 +month(order_date))=3;


--11.List the top 5 products by total revenue for each brand.
---------------------------------------------------------------------
use BikeStorePracticeDB;
select
       *   
from 
    (
    select 
        B.brand_id,B.brand_name,P.product_id,P.product_name,
        sum(OI.quantity*OI.list_price) as Total_revenue,
        rank() over (partition by B.brand_id order by sum(OI.quantity*OI.list_price) desc) as Rnk
    from 
        sales.order_items OI join production.products P on
        OI.product_id=P.product_id join production.brands B on
        P.brand_id=B.brand_id
    group by 
        B.brand_id,B.brand_name,P.product_id,P.product_name
          ) 
     X
where
    X.Rnk<=5
;

--12.Identify customers who have rented both action and comedy films.(use sakila)
----------------------------------------------------------------------------------
use sakila;
select 
    C.customer_id,C.first_name,C.last_name
from 
    category CG join film_category FC on CG.category_id=FC.category_id
    join inventory I on FC.film_id=I.film_id join customer C on
    I.store_id=C.store_id
where 
    CG.name in ('Action','Comedy')
group by 
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct CG.name)=2
order by 
    C.customer_id;

--13.Find the top 3 revenue-generating months for each store
-----------------------------------------------------------------
use BikeStorePracticeDB;
with Y as (
    select 
        ST.store_id,ST.store_name,
        datename(month,O.order_date) as month,
        sum(OI.quantity*OI.list_price) as TotalSales,
        rank() over (partition by St.store_id order by sum(OI.quantity*OI.list_price) desc) as Rnk
    from 
        sales.stores ST join sales.orders O
        on ST.store_id=O.store_id join sales.order_items OI
        on O.order_id=OI.order_id
    group by 
        ST.store_id,St.store_name,datename(month,O.order_date)
    )
select * from Y where Y.Rnk<=3;    



