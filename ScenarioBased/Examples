--Scenario based queries
--------------------------------------------------------------Set 1-----------------------------------------------------------------------------------------------
--1.Write a SQL query to find the customers  who bought every product in the last 6 months. Retrieve customer details.
---------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from 
    sales.customers C join sales.orders O on C.customer_id=O.customer_id
    join sales.order_items OI on O.order_id=OI.order_id
    join production.products P on OI.product_id=P.product_id
where 
    O.order_date>=dateadd(month,-6,(select max(order_date) from sales.orders))
group by 
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct OI.product_id)=(select count(distinct product_id) from production.products);


    --This query works without error,but produces no output since,
    --in the last 6 months,there is no single customer who purchased all of the products

--2.Identify the most sold product (by quantity) for each store and display the product name, store name, and total quantity sold.	
----------------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        ST.store_name,P.product_name,sum(quantity) as QuantitySold,
        rank() over (partition by ST.store_name order by sum(quantity) desc) as Rnk
    from 
        sales.stores ST join sales.orders O on 
        ST.store_id=O.store_id join sales.order_items OI
        on O.order_id=OI.order_id join production.products P
        on OI.product_id=P.product_id
    group by 
        ST.store_name,P.product_name
)
select 
    X.store_name,X.product_name,X.QuantitySold 
from 
    X
where 
    X.Rnk=1;


--3.Write a query to rank customers based on the most expensive product they purchased in each product category.
---------------------------------------------------------------------------------------------------------------------------
-- Firstly, we group the customers and aggreagte to find who ever bought the expensive product in each category and then
-- partition the category to rank each customer by price 
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name,CG.category_id,CG.category_name,
    P.product_name,max(P.list_price) as MaxPrice,
    dense_rank() over (partition by CG.category_id order by max(P.list_price) desc) as RNK
from 
    sales.customers C join sales.orders O on C.customer_id=O.customer_id
    join sales.order_items OI on O.order_id=OI.order_id join
    production.products P on OI.product_id=P.product_id
    join production.categories CG on P.category_id=CG.category_id
group by 
    C.customer_id,C.first_name,C.last_name,CG.category_name,P.product_name,CG.category_id;

--4.Calculate the Year-over-Year Sales Growth.
-------------------------------------------------------------
use BikeStorePracticeDB;
select 
    X.*,
    --calculate growth percentage
    concat(cast((TotalSales-nullif(PreviousYearSales,0))/PreviousYearSales*100 as decimal(4,2)),'%') as GrowthPercent
from
    (
    --calculate year by year total sales and previous sales
    select 
        year(O.order_date) as Year,
        sum(OI.quantity*OI.list_price) as TotalSales,
        lag(sum(OI.quantity*OI.list_price),1,0) over (order by year(O.order_date)) as PreviousYearSales 
    from 
        sales.orders O join sales.order_items OI on O.order_id=OI.order_id
    group by 
        year(O.order_date)
        ) 
    X;


--5.Find the cumulative revenue generated per store over time
-----------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_id,ST.store_name,O.order_date,
    sum(OI.quantity*OI.list_price) as DailySales,
    sum(sum(OI.quantity*OI.list_price)) over (partition by ST.store_id order by O.order_date) as CumulativeRevenue
from 
    sales.Orders O join sales.stores ST on
    O.store_id=ST.store_id join sales.order_items OI
    on O.order_id=OI.order_id
group by 
    ST.store_id,ST.store_name,O.order_date;
        

--6.
-------------------------------------------------------------------------
--duplicate
--same as 5th one

--7.Calculate the total revenue generated by each store, rank the stores based on the total number of orders. Retrieve store_id, total orders (ORDER BY store_id ASC).
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_id,
    count(O.order_id) as Total_orders,
    sum(quantity*(list_price*(1-discount))) as TotalRevenue,
    rank() over (order by count(O.order_id) desc) as rNK
from 
    sales.stores ST join sales.orders O
    on ST.store_id=O.store_id
    join sales.order_items OI
    on O.order_id=OI.order_id
group by 
    ST.store_id
order by 
    ST.store_id;


--8.Find the customers who have spent the most in each store	
-------------------------------------------------------------------------------------------
--firstly we extract every customers total spending in each store.
use BikeStorePracticeDB;
with X as (
    select 
        C.customer_id,C.first_name,C.last_name,ST.store_id,ST.store_name,
        sum(quantity*(list_price*(1-discount))) as Total_spending -- total spending excluding the discount percentage from list price
    from 
        sales.customers C join sales.orders O 
        on C.customer_id=O.customer_id
        join sales.order_items OI
        on O.order_id=OI.order_id
        join sales.stores ST on
        O.store_id=ST.store_id
    group by 
        C.customer_id,ST.store_id,C.first_name,C.last_name,ST.store_name
       ),
-- then we rank each customer in each store by total sales
Y as (
    select 
        X.*,
        row_number() over (partition by store_name order by X.Total_spending desc) as RN
    from 
        X
)
-- then we finally select the top spending customer across each store
select 
    store_id,store_name,customer_id,first_name,last_name,Total_spending
from 
    Y
where 
    Y.RN=1
order by 
    store_id;


--9.Find the customer name who rented the maximum number of films in the last 5 years, where each film features at least two actors.
-------------------------------------------
use sakila;
select top 1 
    C.first_name,C.last_name,
    count(R.rental_id) as No_of_rentals
from 
    customer C join rental R on C.customer_id=R.customer_id
    join inventory I on R.inventory_id=I.inventory_id join
    film F on I.film_id=F.film_id join
    film_actor FA on F.film_id=FA.film_id
where 
    F.film_id in(
            select 
                film_id 
            from 
                film_actor
            group by 
                film_id
            having 
                count(distinct actor_id)>=2
            )
group by 
    C.first_name,C.last_name
order by 
    No_of_rentals desc;


--10.Rank the stores by their total revenue
----------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_name,
    sum(OI.quantity*OI.list_price) as TotalSales,
    rank() over (order by sum(OI.quantity*OI.list_price) desc) as SalesRank
from 
    sales.orders O join sales.stores ST on 
    O.store_id=ST.store_id join sales.order_items OI
    on O.order_id=OI.order_id
group by 
    ST.store_name;


--11.Rank products within each category based on their total sales
-----------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    CG.category_id,CG.category_name,P.product_name,
    sum(OI.quantity*OI.list_price) as TotalSales,
    rank() over (partition by CG.category_id order by sum(OI.quantity*OI.list_price) desc) as Rnk
from 
    sales.order_items OI join production.products P
    on OI.product_id=P.product_id join
    production.categories CG on P.category_id=CG.category_id
group by 
    CG.category_id,CG.category_name,P.product_name;


--12.Find all customers who have placed an order every month in the last 6 months.
----------------------------------------------------------------------------------------------
/*firstly select customer details,
then apply date filter as before 6 months,
here we apply the filter to extract only the records which are 6 months before from last order date
and then group by customer details to find out the count agregate
and to find out whether order has been placed in each of the month,
we create a special identifier for each month like year(order_date)*100+month(order_date)
like for march 2025 it would be  202503 ((2025*100) +3) so that it will be different from other months id
and when counted for distinct months, it must be 6 according to the requirement*/

use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from 
    sales.customers C join sales.orders O on
    C.customer_id=O.customer_id
where 
    O.order_date>=dateadd(month,-6,(select max(order_date) from sales.orders))
    and O.order_date<(select max(order_date) from sales.orders)
group by 
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct (year(order_date)*100+month(order_date)))=6;


--13.Write a SQL query to find top 3 category purchases in each city
------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        C.city,CG.category_id,CG.category_name,
        sum(OI.quantity*OI.list_price) as TotalSales,
        rank() over (partition by C.city order by sum(OI.quantity*OI.list_price) desc) as CategoryRank
    from 
        sales.customers C join sales.orders O
        on C.customer_id=O.customer_id join sales.order_items OI
        on O.order_id=OI.order_id join production.products P
        on OI.product_id=P.product_id join production.categories CG
        on P.category_id=CG.category_id
    group by 
        C.city,CG.category_id,CG.category_name
)
select 
    * 
from 
    X 
where
    X.CategoryRank<=3;


--14.Find the top 3 products that contributed the most to revenue for a specific store. (ORDER BY model_year DESC).
-----------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        ST.store_id,ST.store_name,OI.product_id,P.product_name,P.model_year,
        sum(OI.quantity*OI.list_price) as Total_revenue,
        row_number() over (partition by ST.store_id order by  sum(OI.quantity*OI.list_price) desc) as ProductRank
    from 
        sales.stores ST join sales.orders O
        on ST.store_id=O.store_id join sales.order_items OI on
        O.order_id=OI.order_id join production.products P on
        OI.product_id=P.product_id
    group by 
        ST.store_id,ST.store_name,OI.product_id,P.product_name,P.model_year
)
select 
    * 
from 
    X 
where 
    X.ProductRank<=3 
order by 
    model_year desc;


------------------------------------------------------------------SET 2---------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
--1.Find the top 3 highest revenue-generating stores over time using cumulative revenue.
----------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
--first calculate daily store revenue
with StoreDailyRevenue as (
    select
        ST.store_id,ST.store_name,O.order_date,
        sum(OI.quantity*OI.list_price) as DailyRevenue
    from
        sales.stores ST join sales.orders O on ST.store_id=O.store_id
        join sales.order_items OI on O.order_id=OI.order_id
    group by ST.store_id,ST.store_name,O.order_date
),
--then calculate cumulative revenue by order_date
CumulativeStoreRevenueTable as(
    select
        *,
        sum(DailyRevenue) over (partition by store_id order by order_date) as CumulativeStoreRevenue
    from
        StoreDailyRevenue
),
--then find max cumulative revenue and find out the rank by max cumulative revenue
StoreRank as (
    select store_id,store_name,
    max(CumulativeStoreRevenue) as maxCumRevenue,
    rank() over (order by max(CumulativeStoreRevenue) desc) as Rnk
    from
        CumulativeStoreRevenueTable
    group by
        store_id,store_name
)
--select top 3 ranked stores
select * from StoreRank
where Rnk<=3;

------------------------------------------------------------------alternate way--------------------------
select 
    *  
from 
    (
        select 
            X.store_id,X.store_name,max(X.cumReve) as MaxCumRev,
            rank() over (order by max(X.cumReve) desc) as Rnk
        from(
                select 
                    ST.store_id,ST.store_name,O.order_date,
                    sum(OI.quantity*OI.list_price) over (partition by ST.store_id order by O.order_date ) as cumReve
                from 
                    sales.stores ST join sales.orders O on ST.store_id=O.store_id join sales.order_items OI on O.order_id=OI.order_id
            ) X
         group by 
            X.store_id,X.store_name
        ) Y
where Y.Rnk<=3;


--2.Identify the top 3 best-selling products in each store (Concepts: RANK() or DENSE_RANK()).
----------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    X.* 
from (
    select 
        ST.store_id,ST.store_name,P.product_id,P.product_name,
        sum(OI.quantity) as Total_selling_quantity,
        rank() over (partition by ST.store_id order by sum(OI.quantity) desc) as Rnk
    from 
        sales.stores ST join sales.orders O on
        ST.store_id=O.store_id join sales.order_items OI on 
        O.order_id=OI.order_id join production.products P on
        OI.product_id=P.product_id
    group by 
        ST.store_id,ST.store_name,P.product_id,P.product_name
    ) 
    X
where 
    X.Rnk<=3;

--3.Find the top 3 products, along with their category and brand names, where the delay between the placement of the order and dispatch is the maximum.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select top 3 
    P.product_id,P.product_name,CG.category_name,B.brand_name,
    max(datediff(day,O.required_date,O.shipped_date)) as Max_Delayed_days
from 
    sales.orders O join sales.order_items OI on 
    O.order_id=OI.order_id join production.products P on
    OI.product_id=P.product_id join production.categories CG on
    P.category_id=CG.category_id join production.brands B on
    P.brand_id=B.brand_id
group by 
    P.product_id,P.product_name,CG.category_name,B.brand_name
order by 
    max(datediff(day,O.required_date,O.shipped_date)) desc;


--4.NTILE-Dividing products into price Tiers: Group items into price ranges.
---------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    product_id,product_name,list_price,
    ntile(4) over (order by list_price desc) as price_tier
from 
    production.products;

--5.RANK & DENSE_RANK - Finding Top Selling Products in a Specific Store: Rank 
--items by sales within any group.------------------
use BikeStorePracticeDB;
select 
    ST.store_id,ST.store_name,P.product_id,P.product_name,
    sum(OI.quantity*OI.list_price) as Total_sales,
    rank() over (partition by ST.store_id order by sum(OI.quantity*OI.list_price) desc) as Rnk,
    dense_rank() over (partition by ST.store_id order by sum(OI.quantity*OI.list_price) desc) as DnsRnk
from 
    sales.stores ST join sales.orders O on
    ST.store_id=O.store_id join sales.order_items OI on
    O.order_id=OI.order_id join production.products P on
    OI.product_id=P.product_id
group by 
    ST.store_id,ST.store_name,P.product_id,P.product_name;

--6.PARTITION BY with LEAD & LAG - Comparing Daily Sales: Compare values to previous/next rows within a group.	
----------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with X as (
    select 
        ST.store_id,ST.store_name,O.order_date,
        sum(OI.quantity*OI.list_price) as DailySales
    from 
        sales.stores ST join sales.orders O on
        ST.store_id=O.store_id join sales.order_items OI on
        O.order_id=OI.order_id
    group by 
        ST.store_id,O.order_date,ST.store_name
)
select * from (
    select 
        X.store_id,X.store_name,X.order_date,
        lag(X.DailySales) over (partition by X.store_id order by X.order_date) as PreviousDaySales,X.DailySales,
        lead(X.DailySales) over (partition by X.store_id order by X.order_date) as NextDaySales,
        (X.DailySales-lag(X.DailySales) over (partition by X.store_id order by X.order_date)) as SalesDifference,
        case
            when (X.DailySales-lag(X.DailySales) over (partition by X.store_id order by X.order_date))<0 then 'Decreased Sales'
            when (X.DailySales-lag(X.DailySales) over (partition by X.store_id order by X.order_date))=0 then 'No change'
            when (X.DailySales-lag(X.DailySales) over (partition by X.store_id order by X.order_date))>0 then 'Increased Sales'
            else 'No previous Sales'
        end as GrowthImpact
    from 
         X) Y
--where GrowthImpact='Decreased Sales';
GO

--7.Understand datefunctions , group by , count and use window functions / cte to handle year-over-year analysis
--------------------------------------------------------------------------------------------
use sakila;
--firstly find out yearly total of each actor
with YearlyTotal as (
    select 
        A.actor_id,A.first_name,A.last_name,F.release_year,
        count(F.film_id) as FilmCount
    from 
        actor A join film_actor FA on A.actor_id=FA.actor_id
        join film F on FA.film_id=F.film_id
    group by 
        A.actor_id,A.first_name,A.last_name,F.release_year
        )
--from yearly totals,calculate the average yearly film count of each actor
select
    actor_id,first_name,last_name,FilmCount,
    avg(FilmCount) over (partition by actor_id) as AvgFilmCount
from
    YearlyTotal;


--8.Find stores that have sales on all days of the week
--------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_id,ST.store_name,count(order_id) as Total_orders
from 
    sales.stores ST join sales.orders O on
    ST.store_id=O.store_id
group by 
    ST.store_id,ST.store_name
having 
    count(distinct datepart(weekday,order_date))=7;

--9.List stores that have sold products from every category
-----------------------------------------------------------------------------------------
select 
    ST.store_id,ST.store_name
from
    sales.stores ST join production.stocks SK
    on ST.store_id=SK.store_id join 
    production.products P on SK.product_id=P.product_id
    join production.categories CG on
    P.category_id=CG.category_id
group by
    ST.store_id,ST.store_name
having
    count(distinct CG.category_id)=(
    select count(distinct category_id) from production.categories
    );

--10.Identify customers who placed orders in exactly 3 different months last year.
-------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from
    sales.customers C join sales.orders O on 
    C.customer_id=O.customer_id
where
    order_date>dateadd(year,-1,(select max(order_date) from sales.orders))
    and order_date<=(select max(order_date) from sales.orders)
group by
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct year(O.order_date)*100 +month(order_date))=3;


--11.List the top 5 products by total revenue for each brand.
---------------------------------------------------------------------
use BikeStorePracticeDB;
select
       *   
from 
    (
    select 
        B.brand_id,B.brand_name,P.product_id,P.product_name,
        sum(OI.quantity*OI.list_price) as Total_revenue,
        rank() over (partition by B.brand_id order by sum(OI.quantity*OI.list_price) desc) as Rnk
    from 
        sales.order_items OI join production.products P on
        OI.product_id=P.product_id join production.brands B on
        P.brand_id=B.brand_id
    group by 
        B.brand_id,B.brand_name,P.product_id,P.product_name
          ) 
     X
where
    X.Rnk<=5
;

--12.Identify customers who have rented both action and comedy films.(use sakila)
----------------------------------------------------------------------------------
use sakila;
select 
    C.customer_id,C.first_name,C.last_name
from 
    category CG join film_category FC on CG.category_id=FC.category_id
    join inventory I on FC.film_id=I.film_id join customer C on
    I.store_id=C.store_id
where 
    CG.name in ('Action','Comedy')
group by 
    C.customer_id,C.first_name,C.last_name
having 
    count(distinct CG.name)=2
order by 
    C.customer_id;

--13.Find the top 3 revenue-generating months for each store
-----------------------------------------------------------------
use BikeStorePracticeDB;
with Y as (
    select 
        ST.store_id,ST.store_name,
        datename(month,O.order_date) as month,
        sum(OI.quantity*OI.list_price) as TotalSales,
        rank() over (partition by St.store_id order by sum(OI.quantity*OI.list_price) desc) as Rnk
    from 
        sales.stores ST join sales.orders O
        on ST.store_id=O.store_id join sales.order_items OI
        on O.order_id=OI.order_id
    group by 
        ST.store_id,St.store_name,datename(month,O.order_date)
    )
select * from Y where Y.Rnk<=3;


--14.Find customers who have rented every film in a specific category.
----------------------------------------------------------------------
use sakila;
--firstly select customer_id and no of distinct films each customer has rented in each category
with CustomerCategoryRentals as(
    select 
        C.customer_id,C.first_name,C.last_name,
        fc.category_id,CG.name as Category,
        count(distinct fc.category_id) as NoOfFilms
    from
        customer C join rental R on C.customer_id=R.customer_id 
        join inventory I on I.inventory_id=R.inventory_id 
        join film F on F.film_id=I.film_id 
        join film_category fc on F.film_id=fc.film_id 
        join category CG on fc.category_id=CG.category_id
    group by
        C.customer_id,C.first_name,C.last_name,fc.category_id,CG.name
),
--Then calculate no of distinct films in each category
NoOFFilmsInCategory as (
    select 
        fc.category_id,count(distinct film_id) as TotalFilms
    from
        film_category fc
    group by
        fc.category_id
)
--finally select customer details and category details by joining both CTEs , apply condition as whether total films a customer has rented equals total films in that category
select 
    CCR.customer_id,CCR.first_name,CCR.last_name,CCR.category_id,CCR.Category
from
    CustomerCategoryRentals CCR join
    NoOFFilmsInCategory X on CCR.category_id=X.category_id
where
    CCR.NoOfFilms=X.TotalFilms
order by
    CCR.customer_id;


-------------------------------------------------------SET 3--------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
--1.Find the names of customers who have placed more orders than the average number of orders per customer.
---------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name 
from
    sales.customers C join sales.orders O on C.customer_id=O.customer_id
group by 
    C.customer_id,C.first_name,C.last_name
having 
    count(O.order_id)>(select count(order_id)/count(distinct C1.customer_id) from sales.customers C1 join sales.orders O1 on O1.customer_id=C1.customer_id);


--2.List products that have never been ordered
--------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    P.product_id,P.product_name
from
    production.products P left join sales.order_items OI on P.product_id=OI.product_id
where 
    OI.order_id is null;


--3.Find the store that generated the highest total revenue.
-------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select TOP 1
    ST.store_id,ST.store_name,sum(OI.quantity*OI.list_price) as TotalSales
from
    sales.stores ST join sales.orders O on ST.store_id=O.store_id
    join sales.order_items OI on O.order_id=OI.order_id
group by
    ST.store_id,ST.store_name
order by 
    sum(OI.quantity*OI.list_price) desc;


--4.Show the top 5 products with the highest sales quantity, but only include those from brands whose total sales are above the average sales per brand.
------------------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select TOP 5
    P.product_id,P.product_name,sum(OI.quantity) as TotalQuantity
from
    sales.order_items OI join production.products P on OI.product_id=P.product_id
    join production.brands B on P.brand_id=B.brand_id
where
    B.brand_id in -----only include those from brands whose total sales are above the average sales per brand.
    (--select brand id where total sales greater than average sales per brand
        select 
            B.brand_id 
        from 
            sales.order_items OI join production.products P on OI.product_id=P.product_id
            join production.brands B on P.brand_id=B.brand_id 
        group by 
            B.brand_id
        having 
            sum(OI.quantity*OI.list_price)> ----total sales>avg brand sales
            (--select avg sales per brand
                select 
                    sum(OI.quantity*OI.list_price)/count(distinct B.brand_id) 
                from 
                    sales.order_items OI join production.products P 
                    on OI.product_id=P.product_id join production.brands B 
                    on P.brand_id=B.brand_id
                )
    )
group by
    P.product_id,P.product_name
order by
    TotalQuantity desc;


--5.Find customers who bought all products in a specific category (e.g., 'Mountain Bikes').
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from
    sales.customers C join sales.orders O on C.customer_id=O.customer_id
    join sales.order_items OI on O.order_id=OI.order_id join 
    production.products P on OI.product_id=P.product_id
    join production.categories CG on P.category_id=CG.category_id
where 
    CG.category_name='Mountain Bikes'
group by
    C.customer_id,C.first_name,C.last_name
having--compare the no of purchased products to total no of products
    count(distinct P.product_id)=(--find no of products in selected category
                                   select 
                                       count(distinct products.product_id) 
                                   from 
                                       production.categories join production.products on 
                                       products.category_id=categories.category_id 
                                   where 
                                       category_name='Mountain Bikes'
                                  );


--6.List the names of staff who have handled orders totaling more than the store managerâ€™s orders in the same store.
--------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with staff_orders as (
    select 
        concat(s.first_name, ' ', s.last_name) as staff_name,
        s.store_id, s.staff_id, s.manager_id, count(o.order_id) as total_orders
    from 
        sales.staffs s
        join sales.orders o on o.staff_id = s.staff_id
    group by 
        concat(s.first_name, ' ', s.last_name), s.store_id, s.staff_id, s.manager_id
)
select 
    so.staff_name, 
    so.total_orders as StaffTotalOrders,
    so.store_id,
    m.staff_name AS manager_name,
    m.total_orders AS manager_total_orders
from 
    staff_orders so join staff_orders m
    on so.manager_id = m.staff_id
    and so.store_id = m.store_id
where 
    so.total_orders > m.total_orders;

--7.Show the product with the second highest revenue
--------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    P.product_id,P.product_name,sum(OI.quantity*OI.list_price) as TotalSales
from
    sales.order_items OI join production.products P
    on P.product_id=OI.product_id
group by
    P.product_id,P.product_name
order by
    TotalSales desc
offset 1 rows
fetch next 1 rows only;


--8.List customers whose total order amount is higher than every customer in a specific store (e.g., store_id = 3).
-------------------------------------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select
    C.customer_id,C.first_name,C.last_name,sum(OI.quantity*OI.list_price) as TotalSales
from 
    sales.customers c join sales.orders O on O.customer_id=C.customer_id
    join sales.stores ST on O.store_id=ST.store_id join sales.order_items OI
    on O.order_id=OI.order_id
group by
    C.customer_id,C.first_name,C.last_name
having 
    sum(OI.quantity*OI.list_price)>(
        select 
            max(TotalSales) 
        from (
            select 
                C.customer_id,sum(OI.quantity*OI.list_price) as TotalSales
            from 
                sales.customers C join sales.orders O on
                C.customer_id=O.customer_id join sales.stores ST on
                O.store_id=ST.store_id join sales.order_items OI on
                O.order_id=OI.order_id
            where 
                ST.store_id=3
            group by
                C.customer_id
             ) X  
        );

--9.Find the brand(s) whose cheapest product is more expensive than the most expensive product of another brand.
--------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with CheapExpensive as(
	select
		B.brand_id,B.brand_name,
		min(list_price) as Cheapest,
		max(list_price) as Expensive
	from
		production.brands B join production.products P
		on B.brand_id=P.brand_id
	group by
		B.brand_id,B.brand_name
)
select
	B1.brand_id,B1.brand_name,B1.Cheapest,
    B2.brand_id,B2.brand_name,B2.Expensive
from
	CheapExpensive B1 join CheapExpensive B2
	on B1.brand_id<>B2.brand_id
where
	B1.Cheapest>B2.Expensive
order by B1.brand_id;



--10.Identify stores where no staff member has processed an order in the last 6 months.
----------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select
    ST.store_id,ST.store_name
from
    sales.stores ST
where
    ST.store_id not in(--extract the store ids where orders are processed in last 6 months
                    select 
                        O.store_id
                    from
                        sales.orders O
                    where
                        O.order_date>=dateadd(month,-6,(select max(order_date) from sales.orders))
                    );


--1.PARTITION BY with LEAD & LAG - Comparing Daily Sales: Compare values to previous/next rows within a group.
---------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
with DailySales as(
    select 
        ST.store_id,O.order_date,
        sum(OI.quantity*OI.list_price) as DailySalesTotal
    from 
        sales.stores ST join sales.orders O on ST.store_id=O.store_id
        join sales.order_items OI on O.order_id=OI.order_id
    group by
        ST.store_id,O.order_date
)
select 
    DailySales.*,
    lag(DailySalesTotal) over (partition by store_id order by order_date) as PreviousDaySales,
    lead(DailySalesTotal) over (partition by store_id order by order_date) as NextdaySales,
    DailySalesTotal-lag(DailySalesTotal) over (partition by store_id order by order_date) as SalesDifference
from
    DailySales;
    
--2.List stores that have sold products from every category available in the production.categories table.
----------------------------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    ST.store_id,ST.store_name
from
    sales.stores ST join sales.orders O on ST.store_id=O.store_id
    join sales.order_items OI on O.order_id=OI.order_id
    join production.products P on P.product_id=OI.product_id
    join production.categories CG on P.category_id=CG.category_id
group by
    ST.store_id,ST.store_name
having count(distinct CG.category_id)=(select count(distinct category_id) from production.categories);


--3.Identify customers who placed orders in exactly 3 different months in the last calendar year.
-----------------------------------------------------------------------------
use BikeStorePracticeDB;
select 
    C.customer_id,C.first_name,C.last_name
from
    sales.customers C join sales.orders O on 
    C.customer_id=O.customer_id
where
    O.order_date>=dateadd(year,-1,getdate())
group by
    C.customer_id,C.first_name,C.last_name
having count(distinct(year(O.order_date)*100+month(O.order_date)))=3;

--4.List the top 5 products by total revenue for each brand (use Net Revenue).
--------------------------------------------------------------------------------------------------------------------------
select 
    * 
from   
    (
    select 
        B.brand_id,B.brand_name,P.product_id,P.product_name,
        sum(OI.quantity*OI.list_price*(1-discount)) as TotalRevenue,
        rank() over (partition by B.brand_id order by sum(OI.quantity*OI.list_price*(1-discount)) desc) as Rank
    from
        production.brands B join production.products P on
        P.brand_id=B.brand_id join sales.order_items OI on
        OI.product_id=P.product_id
    group by
        B.brand_id,B.brand_name,P.product_id,P.product_name
      )
      X
where
    X.Rank<=5;
